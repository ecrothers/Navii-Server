import org.apache.tools.ant.filters.ReplaceTokens

def environment = hasProperty('env') ? env : 'ci'
def ver = hasProperty('ver') ? ver : ''

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE")
    }
}

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'spring-boot'

group = 'com.navii.server'

// For deployment-related builds, we will need to pass the version in, otherwise we generate it.
if (ver.equals('')) {
    def MAJOR_VERSION = 1
    def minorVer = hasProperty('minorVersion') ? minorVersion : 'local'
    println "Minor version is $minorVer."
    ver = "${MAJOR_VERSION}.$minorVer".toString()
}

println "Environment is $environment."
println "Service version is $ver."

task writeBuildProperties() << {
    def buildDir = new File("${project.rootDir}/build")
    if (!buildDir.exists()) {
        buildDir.mkdir()
    }
    def buildProps = new File("${project.rootDir}/build/buildinfo.properties")
    def w = buildProps.newWriter()
    w << "version=$ver\n"
    w.close()
}

jar() {
    dependsOn writeBuildProperties
    baseName = 'navi'
    version = ver
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

//mainClassName = 'com.navii.server.Application'

repositories {
    mavenCentral()
}

sourceSets {
    integrationTest {
        java {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
            srcDir file('src/integration-test/java')
        }
        resources {
            srcDir file('src/integration-test/resources')
        }
    }
}

configurations {
    integrationTestCompile.extendsFrom testCompile
    integrationTestRuntime.extendsFrom testRuntime
}

configurations.all {
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
    resolutionStrategy.cacheDynamicVersionsFor 0, 'seconds'
}

dependencies {
    def springBootVersion = '1.3.0.RELEASE'

    compile("org.springframework.boot:spring-boot-starter-thymeleaf:$springBootVersion")
    compile("org.springframework.boot:spring-boot-starter-web:$springBootVersion")
    compile("org.springframework.boot:spring-boot-starter-jdbc:$springBootVersion")
    compile("mysql:mysql-connector-java:5.1.34")
    compile("ch.qos.logback:logback-classic:1.0.13")
    compile("com.amazonaws:aws-java-sdk-s3:1.10.26")
    compile("com.google.guava:guava:18.0")
    compile("com.beust:jcommander:1.35")
    compile("org.scribe:scribe:1.3.5")
    compile("com.googlecode.json-simple:json-simple:1.1.1")
    compile("com.fasterxml.jackson.module:jackson-module-afterburner:2.6.3")
    compile("org.springframework.retry:spring-retry:1.1.2.RELEASE")
    compile("com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.4.0")

    testCompile("org.springframework.boot:spring-boot-starter-test:$springBootVersion")
    testCompile("org.springframework:spring-test:4.2.2.RELEASE")
    testCompile("junit:junit:4.12")
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.7'
}

task integrationTest(type: Test) {
    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath
    outputs.upToDateWhen { false }
}

check {
    dependsOn integrationTest
}

build {
    dependsOn check
}

[test, integrationTest].each { task ->
    task.testLogging {
        events "passed", "skipped", "failed", "standardError"
        showCauses = true
        showExceptions = true
        showStandardStreams = true
    }
}

// Below here are deployment-related tasks. They are not meant to be run locally (may change when/if we decide to run Docker locally).

task copyConfig(type: Copy) {
    from 'src/main/resources/.ebextensions'
    into 'docker-ready/.ebextensions'
}

/* Currently, this task expects the jar to be in the top-level folder. Jenkins is responsible for putting the jar there
 * as part of a copy artifact. We could make this look for a local jar in build/libs if we can't find the one that
 * should have been copied by Jenkins. That, however, implies that we want to do the build/test/configure/deploy in one
 * job, but I'd rather keep the build/package separate from configure/deploy.
 */
task copyJar(type: Copy) {
    from 'build/libs/'
    into 'docker-ready'
    include '*.jar'

    rename { String fileName ->
        fileName = 'navi.jar'
    }
}

task copyDockerfile(type: Copy) {
    from ('config/docker') {
        filter(ReplaceTokens, tokens: [environment: environment, version: ver])
    }
    into 'docker-ready'
}

//task copyOptionSettings(type: Copy) {
//    from "config/beanstalk/optionsettings.json.$environment"
//    into 'build'
//
//    rename { String fileName ->
//        fileName.replace(".$environment", '')
//    }
//}

task zipImage(type: Zip) {
    from 'docker-ready'
    baseName = 'navi'
    destinationDir file('build')
}

task dockerBundle(dependsOn: ['copyConfig', 'copyJar', 'copyDockerfile', 'zipImage']) {}